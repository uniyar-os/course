= Секция № 1. Инструменты.

:toc:

Инструменты важны для каждого разработчика. Если ты тратишь время на то, чтобы разобраться с правильными инструментами, на самом деле ты экономишь время, которое будешь тратить на написание и отладку кода. В этой секции будут рассмотрены основные полезные инструменты.

== 1. Make

Программа `make` обычно используется для построения других програм. Когда ты запускаешь `make`, программа ищет в текущей директории файл `Makefile` и выплняет правила записаные в нём на особом языке.

----
my_first_makefile_rule:
    echo "Hello world"
----

Строительными блоками в `make` служат *правила*. Представленное правило состоит из *цели* (`my_first_makefile_rule`) и *рецепта* (`echo "Hello world"`). Если нужно получить от `make` цель, то нужно запустить в терминале `make my_first_makefile_rule`, это приведёт к тому, что `make` отыщет в `Makefile` запрошеное правило и выполнит соответствующий рецепт — напечатает `Hello world`. Рецепты состоят из команд терминала, можешь попробовать выполнить отдельно `echo "Hello world"` и посмотреть что получится.

Правила могут содержать *зависимости* — те цели, которые необходимо выполнить до выполнения текущего правила. В следующем примере правило `task_two` имеет единственную зависимоть: `task_one`. Если выполнить в терминале `make task_two`, то `make` сначала выполнит `task_one`, а затем `task_two`.

----
task_one:
    echo 1
task_two: task_one
    echo 2
----

=== 1.1. Некоторые факты про `make`

* Если запустить `make` не указывая цель, то из `Makefile` будет выбрана первая цель.
* По соглашению названия целей обычно соответствуют именам файлов. Если файл-цель существует и время его модификации больше, чем время модификации _всех_ его зависимостей, то `make` пропустит рецепт из этого правила. Если файл-цель не существует, `make` будет считать, что время модификации этой цели «начало времен» (минимально возможная в данной системе дата и время). Однако временная метка цели, это время последней модификации соответствующего файла.
* Если запустить `make clean` (служебное действие по удалению созданых файлов), то рецепт будет исполняться каждый раз, поскольку файл `clean` никогда не будет создан. (Для более устойчивой работы попробуй использовать `.PHONY` — интернет в помомщь.)
* Отступы в `Makefile` должны быть табами, а не пробелами.
* Рецепты можно запускать параллельно (одновременно) — `make -j 4` (в данном случае четыре параллельных задачи).
* `make` может создавать правила автоматически, если иное не указано. Например, можешь создать файл `my_program.c` и даже без `Makefile` программа `make` сможет его скомпилировать — `make my_program`.
* Язык правил `Makefile` довольно разнообразен, зачатую можно встретить специальные переменные `$@` и `$<`. Посмотри в интернете зачем они.

== 2. Git

Git — распределенная система контроля версий и система управления исходным кодом (SCM), нацеленная на скорость работы, целостность данных и поддержке распределенных, нелинейных вариантов взаимодействия разработчиков. GitHub — это севис хостинга git-репозиториев, которая помимо собственно git предоставляет множество дополнительных возможностей для взаимодействия пользователей (по факту GitHub — социальная сеть для разработчиков).

В этом курсе git и GitHub будут использоваться для управления программным кодом. Важно изучить git не теоретически, а практически, то есть руками. Попрактикуйся в онлайн-визуализаторе вот здесь: http://git-school.github.io/visualizing-git/.

=== 2.1. Команды для запоминания

`git init` :: Создание репозитория в текущей директории.
`git clone <url>` :: Склонировать репозиторий в новую директорию.
`git status` :: Показывает текущее состояние рабочего дерева.
`git pull <репозиторий> <ветвь>` :: Скачать изменения из одного репозитория в другой или в локальную ветку.
`git push <репозиторий> <ветвь>` :: Отправить локальные изменения в удаленный репозиторий.
`git add <файл(ы)>` :: Добавить содержимое файлов в индекс.
`git commit -m <Сообщение об изменениях>` :: Запись изменений в репозиторий с соответствующми сообщением.
`git branch` :: Получение списка или удаление веток.
`git checkout` :: Переключение на ветку или пути в рабочем дереве.
`git merge` :: Соединение двух или более веток.
`git rebase` :: Перемещение изменений к другой точке в дереве.
`git diff [--staged]` :: Построчное сравнение между текущей директорией и индексом (или между индексом и `HEAD`, при наличии `--staged`).
`git show` [--format=raw] <коммит, ветвь, тэг> :: Вывод подробной информации о чём угодно.
`git reset` [--hard] <коммит, ветвь, тэг> :: Сброс текущего состояния репозитория.
`git log` :: Список коммитов в текущей ветви.
`git reflog` :: Изменения в локальном репозитории.

Отмтим, что git особенно полезен при одновременной работе нескольких людей с одной и той же кодовой базой.

== 3. GDB

Программа `gdb` — отладчик (дебаггер), поддерживающий C, C++ и другие языки. Без хорошего понимания работы `gdb` тебе будет тяжело эффективно отлаживать программы. Так что пора познакомиться с ним поближе.

=== 3.1. Команды для изучения

`run, r` :: Запуск программы с точки входа. Поддерживает задание аргументов и простое перенаправление ввода/вывода.
`quit, q` :: Выход из `gdb`.
`kill` :: Остановка выполняемой программы.
`break, break ... if <условие>, clear` :: Задание точки останова при входе в функцию (например `break strcpy`) или на конкретной строчке кода (например `break file.c:80`).
`step, s` :: Если текущая строка кода содержит вызов функции, то `gdb` шагнёт внутрь тела этой функции. Если вызова функции нет, то будет выполнена текущая строка и выполнение остановится на следующей.
`next, n` :: Выполнение текущей строки кода и остановка на следующей. В вызовы функций не заходит.
`continue, c` :: Продолжение выполнения (до следующей точки останова или до конца программы).
`finish` :: Выполнение текущей фукции до конца.
`print, p` :: Вывод значения переменной.
`call` :: Выполнение произвольного кода и вывод результатов.
`watch, rwatch, awatch` :: Останов программы при достижении заданного условия (например `x > 5`).
`backtrace, bt, bt full` :: Вывод порядка вызовов в стеке в текущем состоянии программы.
`disassemble` :: Вывод кода текущей функции на ассемблере.
`set follow-fork-mode <режим>` (MacOS это не поддерживает) :: `gdb` может одновременно отлаживать только один процесс. Если происходит `fork` (процесс клонирует себя), `gdb` может продолжить отладку в родителе (оригинале) или потомке (клоне). `Режим` может принимать значения `parent` и `child` соответственно.

Команды `print` и `call` могут применяться для выпонения произвольных строк кода во время выполнения программы! Можно менять значения переменных и вызывать функции. Например, `call close(0)` или `print i = 4`. (На самом деле в большинстве случаев `print` и `call` взаимозаменяемы). Это одна из наиболее мощных возможностей `gdb`.

== Отладка программ в Linux
=== strace и ltrace
=== catchsegv
=== top
=== ps
=== pidof и pgrep
=== proc
=== lsof
=== netstat и ip
=== kill, pkill и killall
